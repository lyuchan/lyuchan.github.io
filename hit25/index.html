<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WASD 移動切換圖片</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            background: #000;
            /* 黑底 */
            overflow: hidden;
            /* 防止捲動條 */
        }

        .stage {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #sprite {
            position: absolute;
            top: 0;
            left: 0;
            user-select: none;
            -webkit-user-drag: none;
            image-rendering: auto;
            transform: translateZ(0);
            z-index: 10;
        }

        .hint {
            position: absolute;
            left: 12px;
            bottom: 12px;
            color: #8a8a8a;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            font-size: 14px;
            letter-spacing: 0.2px;
        }

        /* 被攜帶的物件與丟出的物件 */
        .held,
        .drop {
            position: absolute;
            pointer-events: none;
        }

        /* 未放下前：在角色之上 */
        .held {
            z-index: 20;
        }

        /* 放下後：在角色之下 */
        .drop {
            z-index: 1;
        }
    </style>
</head>

<body>
    <div class="stage" id="stage">
        <img id="sprite" src="img1.png" alt="sprite" />
        <div class="hint">WASD 移動；移動中每 20–100ms 隨機在 img1/img2 切換；R 重置；?scale=1.0 可調整大小</div>
    </div>

    <script>
        (function () {
            const sprite = document.getElementById('sprite');
            const stage = document.getElementById('stage');
            const params = new URLSearchParams(location.search);
            const scaleParam = parseFloat(params.get('scale'));
            const SCALE = Number.isFinite(scaleParam) && scaleParam > 0 ? scaleParam : 1; // 透過 ?scale=1.5 調整大小
            // 原圖左上角起算的錨點（指定為中心點）：W523px * H373px（原始像素），隨 SCALE 放大
            const ANCHOR_ORIG_X = 523;
            const ANCHOR_ORIG_Y = 373;
            let anchorOffsetX = ANCHOR_ORIG_X * SCALE; // 縮放後錨點 X（相對圖像左上角）
            let anchorOffsetY = ANCHOR_ORIG_Y * SCALE; // 縮放後錨點 Y（相對圖像左上角）
            function updateAnchorOffsets() {
                anchorOffsetX = ANCHOR_ORIG_X * SCALE;
                anchorOffsetY = ANCHOR_ORIG_Y * SCALE;
            }

            // 預先載入影格與物件，避免首次切換時閃爍
            const frames = ['img1.png', 'img2.png'];
            const preloaded = frames.map((src) => { const i = new Image(); i.src = src; return i; });
            const OBJ_SRC = 'obj1.png';
            const objPreload = new Image();
            objPreload.src = OBJ_SRC;

            const pressedKeys = new Set();
            // 以「錨點」為移動座標（WASD 控制的是錨點位置，而非圖片左上角）
            let posX = 0;
            let posY = 0;
            let lastTime = performance.now();
            let lastToggleTime = 0;
            let nextToggleDelay = 0; // 本輪切換需要等待的毫秒數（20~100）
            let currentFrameIndex = 0;

            function rollNextToggleDelay() {
                // 20 ~ 100ms 之間的整數
                nextToggleDelay = Math.floor(20 + Math.random() * 81);
            }
            rollNextToggleDelay();
            const TOGGLE_INTERVAL_MS = null; // 已不再使用固定間隔
            // 物理參數
            let velX = 0, velY = 0;
            const ACCEL_PER_SEC = 1600;      // 按壓方向鍵的加速度 (px/s^2)
            const DRAG_COEFF = 2;          // 空氣阻力係數（越大減速越快）
            const BOUNCE = 3;             // 與邊界碰撞的反彈係數
            const MAX_SPEED = 24000;          // 速度上限 (px/s)

            function setRandomStart() {
                posX = Math.random() * window.innerWidth;
                posY = Math.random() * window.innerHeight;
            }

            // 取得圖片尺寸（含縮放），以便邊界限制
            let spriteWidth = 0;   // 會儲存「縮放後」的寬度
            let spriteHeight = 0;  // 會儲存「縮放後」的高度
            function updateSpriteMetrics() {
                const naturalW = sprite.naturalWidth || sprite.clientWidth || 0;
                const naturalH = sprite.naturalHeight || sprite.clientHeight || 0;
                const scaledW = Math.max(0, naturalW * SCALE);
                const scaledH = Math.max(0, naturalH * SCALE);
                // 實際套用尺寸，避免使用 transform: scale 影響位移單位
                if (scaledW > 0) {
                    sprite.style.width = scaledW + 'px';
                    sprite.style.height = 'auto';
                }
                spriteWidth = scaledW;
                spriteHeight = scaledH;
            }
            sprite.addEventListener('load', updateSpriteMetrics);
            if (sprite.complete) updateSpriteMetrics();

            // 物件尺寸（含縮放），以及被攜帶物件與已丟出物件集合
            let objWidth = 0;
            let objHeight = 0;
            function updateObjectMetrics() {
                const naturalW = objPreload.naturalWidth || 0;
                const naturalH = objPreload.naturalHeight || 0;
                objWidth = Math.max(0, naturalW * SCALE);
                objHeight = Math.max(0, naturalH * SCALE);
                if (held) {
                    if (objWidth > 0) {
                        held.style.width = objWidth + 'px';
                        held.style.height = 'auto';
                    }
                }
            }
            objPreload.addEventListener('load', updateObjectMetrics);
            if (objPreload.complete) updateObjectMetrics();

            const drops = [];
            // 移除鋪牆機制，改用彈性碰撞
            const held = document.createElement('img');
            held.className = 'held';
            held.alt = 'held';
            held.src = OBJ_SRC;
            stage.appendChild(held);

            function isMoving() {
                return pressedKeys.size > 0;
            }

            function clamp(val, min, max) {
                return Math.max(min, Math.min(max, val));
            }

            function onKeyChange(e, isDown) {
                const key = e.key.toLowerCase();
                if (key === 'w' || key === 'a' || key === 's' || key === 'd') {
                    e.preventDefault();
                    if (isDown) pressedKeys.add(key); else pressedKeys.delete(key);
                } else if (key === 'r' && isDown) {
                    e.preventDefault();
                    resetAll();
                }
            }

            window.addEventListener('keydown', (e) => onKeyChange(e, true));
            window.addEventListener('keyup', (e) => onKeyChange(e, false));

            function step(now) {
                const deltaSec = (now - lastTime) / 1000;
                lastTime = now;

                // 方向輸入：加速度（按越久速度越快），鬆開則僅受阻力影響慢慢停
                let ax = 0, ay = 0;
                if (pressedKeys.has('a')) ax -= ACCEL_PER_SEC;
                if (pressedKeys.has('d')) ax += ACCEL_PER_SEC;
                if (pressedKeys.has('w')) ay -= ACCEL_PER_SEC;
                if (pressedKeys.has('s')) ay += ACCEL_PER_SEC;

                velX += ax * deltaSec;
                velY += ay * deltaSec;

                // 空氣阻力（與速度成比例，方向相反）
                velX -= velX * DRAG_COEFF * deltaSec;
                velY -= velY * DRAG_COEFF * deltaSec;

                // 速度上限
                const speed = Math.hypot(velX, velY);
                if (speed > MAX_SPEED) {
                    const k = MAX_SPEED / speed;
                    velX *= k; velY *= k;
                }

                // 積分位置（基於錨點）
                posX += velX * deltaSec;
                posY += velY * deltaSec;

                // 與邊界的彈性碰撞（以錨點為界）
                if (posX < 0) { posX = 0; velX = -velX * BOUNCE; }
                if (posX > window.innerWidth) { posX = window.innerWidth; velX = -velX * BOUNCE; }
                if (posY < 0) { posY = 0; velY = -velY * BOUNCE; }
                if (posY > window.innerHeight) { posY = window.innerHeight; velY = -velY * BOUNCE; }

                // 移動時切換影格
                if (isMoving()) {
                    if (now - lastToggleTime >= nextToggleDelay) {
                        lastToggleTime = now;
                        rollNextToggleDelay();
                        currentFrameIndex = 1 - currentFrameIndex;
                        const nextSrc = frames[currentFrameIndex];
                        if (sprite.src.indexOf(nextSrc) === -1) sprite.src = nextSrc;

                        // 每次切到第 2 張（索引 1）時丟出 1 個，大小隨機為 1–3 倍
                        if (currentFrameIndex === 1) {
                            const drop = document.createElement('img');
                            drop.className = 'drop';
                            drop.src = OBJ_SRC;
                            drop.alt = 'drop';
                            const scaleFactor = 1 + Math.random() * 2; // 1~3 倍
                            const dropW = objWidth * scaleFactor;
                            const dropH = objHeight * scaleFactor;
                            if (dropW > 0) {
                                drop.style.width = dropW + 'px';
                                drop.style.height = 'auto';
                            }

                            // 丟出位置：讓物件中心對齊錨點
                            const holdX = posX - dropW / 2;
                            const holdY = posY - dropH / 2;
                            drop.style.transform = `translate(${holdX}px, ${holdY}px)`;
                            stage.appendChild(drop);
                            drops.push(drop);
                        }
                    }
                } else {
                    // 停止時回到第一張
                    currentFrameIndex = 0;
                    if (sprite.src.indexOf(frames[0]) === -1) sprite.src = frames[0];
                }

                // 實際套用位置：以錨點反推圖片左上角
                const renderX = posX - anchorOffsetX;
                const renderY = posY - anchorOffsetY;
                sprite.style.transform = `translate(${renderX}px, ${renderY}px)`;

                // 更新被攜帶物件位置：讓被攜帶物件中心對齊錨點
                const followX = posX - objWidth / 2;
                const followY = posY - objHeight / 2;
                held.style.transform = `translate(${followX}px, ${followY}px)`;

                requestAnimationFrame(step);
            }

            // 窗口改變時與影格變更後，確保仍在邊界內
            window.addEventListener('resize', () => {
                updateSpriteMetrics();
                updateAnchorOffsets();
                posX = clamp(posX, 0, window.innerWidth);
                posY = clamp(posY, 0, window.innerHeight);
            });

            // 啟動前隨機錨點位置
            setRandomStart();
            requestAnimationFrame((t) => { lastTime = t; requestAnimationFrame(step); });

            function resetAll() {
                // 清除所有已丟出的物件
                for (const el of drops.splice(0)) {
                    if (el && el.parentNode) el.parentNode.removeChild(el);
                }
                // 重置位置（隨機）與影格、速度
                setRandomStart();
                velX = 0;
                velY = 0;
                currentFrameIndex = 0;
                sprite.src = frames[0];
                lastToggleTime = performance.now();
                rollNextToggleDelay();
                pressedKeys.clear();
                // 邊界接觸重置
                edgeContact.left = edgeContact.right = edgeContact.top = edgeContact.bottom = false;
            }

            // 移除鋪牆函式（保留空定義避免引用錯誤）
            function triggerRebound() { }

            // 解析 transform: translate(xpx, ypx)
            function parseTranslateXY(transform) {
                const m = /translate\(([-\d.]+)px,\s*([-\d.]+)px\)/.exec(transform || '');
                if (!m) return { x: 0, y: 0 };
                return { x: parseFloat(m[1]) || 0, y: parseFloat(m[2]) || 0 };
            }

            // 自癒鋪滿移除
        })();
    </script>
</body>

</html>